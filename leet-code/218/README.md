![](https://pic-1302575189.cos.ap-guangzhou.myqcloud.com/mcr/20220721223142.png)

使用扫描线从左到右扫描，扫描算法的关键点是：
1. 扫描线从左到右移动
2. 遇到矩形左边，加入高度值；遇到矩形右边，移除高度值
3. 最大高度发生变化的时候，产生一个新的关键点。横坐标是当前矩形边的横坐标，纵坐标是当前的最大高度值。

当扫描线从左到右横穿的时候，有时候不会穿过任何矩形，但是会产生关键点，高度为0，比如上述例子中的（4，0）

假设现在有上图所示的矩形图，需要维护两个变量，高度集合 result 和 最大高度 maxHeight。

1. 开始可以将高度0加入到高度集合中，并且初始化最大高度为0。此时 result=[0], maxHeight=0
2. 接下来遇到扫描线，于是将2加入到高度集合中。此时 result=[0,2], maxHeight=2。由于最大高度 maxHeight 发生变化，需要记录一个关键点，坐标是（1,2）
3. 接下来继续扫描，遇到2号矩形的左边，将它的高度3加入到高度集合中，此时 result=[0,2,3]，并且更新最大值 maxHeight = 3。最大高度发生变化，产生一个新的关键点（2,3）
4. 接着继续扫描，遇到1号矩形的右边，将它的高度2移除，result=[0,3]。最大值不变，不会产生新的关键点。
5. 接着继续扫描，遇到2号矩形的右边，需要将它的高度3移除，result=[0]，最大高度值 maxHeight=0 发生变化，于是产生一个新的关键点（4,0）
6. 接着继续扫描，遇到3号矩形的左边，把它的高度2加入到集合中，result=[0,2]，并且更新最大高度值 maxHeight=2，于是产生一个新的关键点（5,2）
7. 接着继续扫描，遇到4号矩形的左边，把它的高度4加入到集合中，result=[0,2,,4]，并且更新最大高度值 maxHeight=4，于是产生一个新的关键点（6,4）
8. 接着继续扫描，遇到4号矩形的右边，需要把它的高度4移除，result=[0,2]，最大高度值更新 maxHeight=2，于是产生一个新的关键点（8,2）
9. 接着继续扫描，遇到3号矩形的右边，需要把它的高度2移除，result=[0]，最大高度 maxHeight=0，于是产生一个新的关键点（9,0）

![image-20220723115934740](https://pic-1302575189.cos.ap-guangzhou.myqcloud.com/mcr/20220723115942.png)

至此，扫描的过程结束。在扫描的过程中，我们可以很容易的分析到，是按矩形的左右两条边的横坐标进行排序的。

那么问题来了，如果两个矩形的左边横坐标相同，或者右边的横坐标相同，此时谁应该排在前面。

![image-20220723120014179](https://pic-1302575189.cos.ap-guangzhou.myqcloud.com/mcr/20220723120014.png)

比如对于图2，矩形1和2左边横坐标相同，但是高度不同，显然，对于这种情况，我们需要将矩形2的高度3先加入到结果集中，这样才能得到正确的关键点。加入把1号矩形的左边的高度2先加入到集合中，此时2号矩形还没有处理，当前result=[0,2]，当前最大高度 maxHeight = 2，于是我们会产生一个关键点（2,2），显然这是不对的。

于是我们得出第一个结论：**如果横坐标相同，并且是矩形的左边，则把高度大的排在前面**。

我们再来看矩形的右边，此时的高度集合result=[0,3,2]，最大值 maxHeight=3。如果高度3排在前面，则会先从高度集合中移除3，此时1号矩形的高度2还在集合中，最大高度 maxHeight=2，此时会产生一个关键点（4,2），显然这是不对的。因此我们要将较小的高度2排在前面。

于是我们得到第二个结论：**如果横坐标相同，并且是矩形的右边，则把较小的高度排在前面**。

这里有个小技巧可以把两种情况统一起来，对于矩形的左边，我们存储这个矩形高度的相反数。对于上述的例子，矩形1的左边可以存储（2，-2），2表示横坐标，-2的绝对值表示高度 && 矩形的左边。矩形1的右边可以对应（4,2）。4表示横坐标，2表示纵坐标 && 矩形的右边。同理矩形2可以得到元组（2，-3）和（4,3）。

我们对元组的排序规则是：先按照横坐标排序，如果第一个元素相等，再让第二个元素升序排序。按照这个规则排序，得到的元组数据是：

1. （2，-3）
2. （2，-2）
3. （4，2）
4. （4，3）

最后还有一种边界情况，两个矩形相邻。比如图中的3和4，用上述方法将3和4的元组数据排序。

1. （7，-4）4号矩形的左边
2. （7，2）3号矩形的右边

此时结果集 result=[0,2]，maxHeight=2。这种排序能让高度4先加入集合，从而产生一个正确的关键点（7，4）。而不会错误的将高度2先从集合中移除，从而产生一个错误的关键点（7，0）。

上述的方法需要维护一个最大堆，需要遍历高度数组一次，花费 O(n)。而每次操作需要移除高度值，而在堆中移除一个高度值是 O(n)。因此 T(n) = O(n^2)，需要使用一个辅助堆，S(n) = O(n)。

这个算法可以把辅助堆换成红黑树，红黑树的删除操作是 O(lgn)。因此时间复杂度可以降低为 T(n) = O(n*lgn) 

