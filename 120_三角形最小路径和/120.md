## 题目链接
https://leetcode-cn.com/problems/triangle/

## 解题思路
这道题非常有意思，可以从以下几个方面来思考一下：

### 分治递归
首先回忆下递归的三要素：
1. 递归的定义：寻找一条，从(x,y)出发，走到最底层的一条最短路径，并返回
2. 递归的过程：从(x,y)开始，可以向(x+1,y)或者(x+1,y+1)走
3. 递归终止：到了最底层结束，返回选择的路径

所以这道题可以看为：
1. 递归的过程：
```go
return triangle[x][y] + min(dfs(triangle, x+1, y), dfs(triangle, x+1, y+1))
```
2. 递归终止：
```go
if x == len(triangle) {
    return 0
}
```

这种是采用分治思想的递归算法，将一个大问题拆解为多个小问题：即求得当前节点到最底层的路径最小值，就可以求的从(x,y)到最底层节点
的最小值。这道题的时间复杂度可以这么简单的计算：每一层往下都会劈叉为2，有n层，所以复杂度=2^n。2^n必定会超时，所以需要用额外的
空间来优化下算法，使用一个hash数组来存储已经访问过节点的最短路径。

常规的递归的时间复杂度计算 = 一共有多少个节点 * 每个节点被调用的次数 * 每个点上处理的时间复杂度。所以这道题可以看为
- 多少个节点 = (1+2+3+...+n) = O(n^2)
- 每个点上被调用的次数 = 最多2次（第一次是用来计算的，第二次被访问到，但hash数组中已经存储了）
- 每个点上处理的时间复杂度 = O(1)

所以这道题最终的时间复杂度为：O(n^2)

### 递归
这里还有一种递归思路，即从根节点(x,y)开始访问到底层，将所有路径都求一次，通过比较来获取最短路径。简单来说，就是在递归终止时，
使用一个变量来存储最短路径即可。
```go
if x == len(triangle) {
    result = min(result, pathSum)
    return
}
```

这种情况下也会导致栈溢出或者超时，因为其时间复杂度也是2^n

### 动态规划

