## 题目链接
https://leetcode-cn.com/problems/triangle/

## 解题思路
这道题非常有意思，可以从以下几个方面来思考一下：

### 分治递归
首先回忆下递归的3要素：
1. 递归的定义：寻找一条，从(x,y)出发，走到最底层的一条最短路径，并返回
2. 递归的过程：从(x,y)开始，可以向(x+1,y)或者(x+1,y+1)走
3. 递归终止：到了最底层结束，返回选择的路径

所以这道题可以看为：
1. 递归的过程：
```go
return triangle[x][y] + min(dfs(triangle, x+1, y), dfs(triangle, x+1, y+1))
```
2. 递归终止：
```go
if x == len(triangle) {
    return 0
}
```

这种是采用分治思想的递归算法，将一个大问题拆解为多个小问题：即求得当前节点到最底层的路径最小值，就可以求的从(x,y)到最底层节点
的最小值。这道题的时间复杂度可以这么简单的计算：每一层往下都会劈叉为2，有n层，所以复杂度=2^n。2^n必定会超时，所以需要用额外的
空间来优化下算法，使用一个hash数组来存储已经访问过节点的最短路径。

常规的递归的时间复杂度计算 = 一共有多少个节点 * 每个节点被调用的次数 * 每个点上处理的时间复杂度。所以这道题可以看为
- 多少个节点 = (1+2+3+...+n) = O(n^2)
- 每个点上被调用的次数 = 最多2次（第一次是用来计算的，第二次被访问到，但hash数组中已经存储了）
- 每个点上处理的时间复杂度 = O(1)

所以这道题最终的时间复杂度为：O(n^2)

### 递归
这里还有一种递归思路，即从根节点(x,y)开始访问到底层，将所有路径都求一次，通过比较来获取最短路径。简单来说，就是在递归终止时，
使用一个变量来存储最短路径即可。
```go
if x == len(triangle) {
    result = min(result, pathSum)
    return
}
```

这种情况下也会导致栈溢出或者超时，因为其时间复杂度也是2^n

### 动态规划
动态规划4要素，参考064
1. state：f[x][y] = 从(0,0)->(x,y)的最短路径
2. function：f[x][y] = min(f[x-1][y], f[x-1][y-1]) + triangle[x][y]
3. initialization: 起点
4. answer：min(f[m-1][0], f[m-1][1], f[m-1][2], ..., f[m-1][n-1])

因为只用了三角形的左下部分，这里的初始化第一列和斜线
```go
// 初始化第一列和斜着的
for i := 1; i < m; i++ {
    sum[i][0] = sum[i-1][0] + triangle[i][0]
    sum[i][i] = sum[i-1][i-1] + triangle[i][i]
}
```
